### Bean 作用域

Spring支持五种作用域，后三种在web环境才生效(了解即可)：

| 作用域        | 说明                                |
| ------------- | ---------------------------------- |
| ==singleton== | 容器内同名称的bean只有一个实例(默认) |
| ==prototype== | 每次使用该bean时会创建新实例         |
| request       | 每个请求范围内会创建新实例           |
| session       | 每个会话范围内会创建新实例           |
| application   | 每个应用范围内会创建新实例           |

- 默认作用域是`singleton`，会在项目启动时创建
  - 如果需要延迟启动，就在bean类处加上 `@lazy` 注解
- 通过`@Scope("prototype")` 注解可将bean类作用域修改成`prototype`
  - 会在每次bean被调用时，创建新实例

-------------------------------------------------------------
### singleton(单例) prototype(多例) 使用场景

单例bean：
```java
    @RestController
    // @Scope("singleton")  默认，可不写
    public class DeptController {

        @Autowired
        private DeptService deptService;

        @GetMapping("/depts")
        public Result list() {
            log.info("查询全部部门数据");
            List<Dept> deptList = deptService.findAll();
            return Result.success(deptList);
        }
    }
```
> 无状态bean：Bean 内部**不保存**“与某一次请求相关的状态数据”
> 由于没有状态，同一实例被多线程调用也不会出现数据改动，此时适合 `单例bean`，多次调用同一实例，省性能


多例bean:
```java
    @Component
    @Scope("prototype")
    public class DataProcessor {

        private List<EmpModel> dataList = new ArrayList<EmpModel>(); // 暂存数据
        private Integer errCount = 0; // 错误数据统计

        @Autowired
        private EmpMapper empMapper;

        public void process(List<Emp> empList) {
            dataList = empList.stream().map(emp -> {
                // 数据处理
            }).toList();
        }

        public void handle() {
            // ...
        }
    }
```
> 有状态的bean：Bean 内部通过“成员变量”**保存**了业务过程中的中间状态或统计结果，并且这些状态会随着方法调用而变化。
> 因为有状态，假设只有单一例的话，多线程调用后，数据会发生改动，不安全，不健康。所以适合 `多例bean` ，每次被调用创建新实例，防止数据问题