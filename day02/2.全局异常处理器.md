**全局异常处理器：**
- 通过单独的异常处理类，来统一管理项目中的异常抛出，统一向前端返回Result.error()之类的异常报错
- 最典型的使用方式就是账号密码的判断
  
  1. 首先需要创建`GlobalExceptionHandler`类:
   ```java
    @RestControllerAdvice
    public class GlobalExceptionHandler {

        @ExceptionHandler
        public Result exceptionHandler(Exception e){
            log.error("异常 {}", e.getMessage());
            return Result.error(e.getMessage());
        }

        @ExceptionHandler
        public Result handleException(AccountNotFoundException e){
            log.error("异常 {}", e.getMessage());
            return Result.error("アカウントは存在しない");
        }

        @ExceptionHandler
        public Result handleException(PasswordErrorException e){
            log.error("异常 {}", e.getMessage());
            return Result.error("パスワードは正しくない");
        }
    }
   ```
   2. 再创建非java或spring自带的异常，也就是自定义异常
   ```java
    public class PasswordErrorException extends RuntimeException {

        public PasswordErrorException(String message) {
            super(message);
        }
    }
   ```
-----------------------------------------------------------------
**数据库主键冲突后的异常处理：**
- 使用全局异常处理器，否则的话前端仅仅会返回 500 响应码，导致无法快速定位问题所在
    - 在通过全局代码处理返回错误信息后，可以明确知道问题是主键冲突 (账号已存在)

  代码模板如下，第二个方法开始为主键冲突处理:
  ```java
        /**
        * 全局异常处理器，处理项目中抛出的业务异常
        */
        @RestControllerAdvice
        public class GlobalExceptionHandler {

            @ExceptionHandler
            public Result exceptionHandler(BaseException ex){
                log.error("异常信息：{}", ex.getMessage());
                return Result.error(ex.getMessage());
            }

            @ExceptionHandler
            public Result exceptionHandler(SQLIntegrityConstraintViolationException ex){
                    
                //完整错误信息：Duplicate entry 'zhangsan' for key 'employee.idx_username'
                String message = ex.getMessage();
                if(message.contains("Duplicate entry")){
                    String[] split = message.split(" ");

                    //split[2]为username
                    return Result.error(split[2] + MessageConstant.ALREADY_EXIST);
                }else{
                    return Result.error(MessageConstant.UNKNOWN_ERROR);
            }
        }
    }
    ```