### 过滤器(Filter)
- 过滤器一般用于完成一些`通用操作`，如：登录校验，统一编码处理，敏感字符处理等
  
- 整个过滤器的调用流程是：
    拦截 → 执行拦截逻辑 → 执行`chain.doFilter()`放行到下一个过滤器类或直接获取资源 → 最后执行放行后逻辑
    - Tip：过滤器放行到下一个过滤器叫做过滤器链，过滤器的优先级是按照类名的字母排序走的

##### 入门程序：

  1. 首先创建过滤器类，并实现Filter接口的三个方法：`init, doFilter, destroy`，并在类上写`@WebFilter`并指定拦截请求类
  ```java
                @WebFilter(urlPatterns = "/*")  // * 为占位符，表示拦截所有请求
                public class DemoFilter implements Filter {   //接入Filter导包是Servlet的包，不要弄个错了

                    //初始化方法，web服务器启动的时候执行一次，不需要时可以不重写
                    //不常用
                    public void init(FilterConfig filterConfig) throws ServletException {
                        log.info("init 过滤器初始化方法");
                    }

                    //拦截请求方法，拦截到请求之后执行，执行多次。是核心方法，必须重写实现
                    //常用
                    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
                        //拦截前端发送的请求
                        log.info("doFilter 过滤器拦截了请求");
                        //放行请求
                        filterChain.doFilter(servletRequest, servletResponse);
                        log.info("doFilter 过滤器放行了请求");
                    }

                    //销毁方法，web服务器关闭的时候执行一次，用于资源释放，不需要时可以不重写
                    //不常用
                    public void destroy() {
                        log.info("destroy 过滤器销毁方法");
                    }
                  }
  ``` 
  
  2. 在启动类或者引导类上加入`@ServletComponentScan`，开启对Servlet组件的支持，用于启动Filter
  <br>
**切记在`doFiler方法`中,请求验证合法后使用`filterChain.doFilter(servletRequest, servletResponse);`放行**

---------------------------------------------------------------------------------------------------------------------------
#### 项目流程中的过滤器使用
<div align="center"> <img src=".\picture\过滤器流程图.png" alt="流程图" width="500"> </div>

---------------------------------------------------------------------------------------------------------------------------
#### 令牌校验模板代码 - Filter：
- 预先须知：所有请求`request`以及响应`response`，都会被封装到`HttpServletRequest`和`HttpServletResponse`类中
- 要获取请求路径和前端存储的令牌，则需要调用
```
                        - request.getRequestURI();
                        - request.getHeader("token");
```
<div><b>注意：</b>这里仅仅是模板代码，检验(解析)token的判断依据仅仅只有token格式是否合法，以及是否过了有效期。而实际的项目中还需要二次检验账号状态等验证</div>
<br>

```java
@WebFilter(urlPatterns = "/*")
public class TokenFilter implements Filter {

    private JwtProperties jwtProperties = new JwtProperties();    

    //拦截请求方法
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;

        // 1. 获取请求路径
        String uri = request.getRequestURI();

        // 2. 判断路径是否 包含 登录路径，如果有就直接放行  // 静态资源也要一起放行，否则不能渲染
        if (uri.contains("/login") || uri.contains("/CSS/") || uri.contains("/json/")) {
            log.info("登录请求，放行");
            filterChain.doFilter(request, response);
            return;
        }
        // 3. 获取请求头中的token
        String token = request.getHeader("token");

        // 4. 并判断token是否存在或是空字符串
        if (token == null || token.isEmpty()) {
            log.info("令牌不存在，响应401");
            // 设置响应码为401，以返回给前端            401
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }
        // 5. 校验token
        jwtProperties.setSecretKey("...");  //因为Filter不能@AutoWired，所以手动设置密钥，实际项目情况下这种做法是错误的，这里仅仅是为了程序能跑
        try{
            JwtUtil.parseJwt(token, jwtProperties.getSecretKey());
        }catch (Exception e){
            log.info("令牌非法，响应401");
            // 设置响应码为401，以返回给前端            401
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }
        // 6. 校验通过则放行
        log.info("令牌合法，放行");
        filterChain.doFilter(request, response);
    }
}
```