### 拦截器
- 概念：是一种动态拦截方法调用的机制，类似于过滤器。Spring框架提供，用于动态拦截控制器方法执行
- 作用：拦截请求，在指定的方法调用前后，根据业务需要执行预先设定的代码
  
#### 入门程序
1. 定义拦截器，继承`HandlerInterceptor接口`，并实现所需方法
```java
    @Component  //实现拦截器的前提是需要注册一个配置类(configuration包中)
    public class DemoInterceptor implements HandlerInterceptor {

        @Override //目标资源方法访问前执行，返回true则放行，false则不放行
        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
            log.info("preHandle...");
            return true;
        }

        @Override //目标资源方法(Object handler)访问完成后，执行
        public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {
            log.info("postHandle...");
        }

        @Override //视图渲染完毕后执行，前后端分离的情况不需要用此方法
        public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {
            log.info("afterCompletion...");
        }
    }
```

2. 注册拦截器，继承`WebMvcConfigurer接口`配置需要拦截的请求和路径(configuration包中)
```java
    @Configuration
    public class WebConfig implements WebMvcConfigurer {

        @Autowired  // 创建拦截器实例
        private DemoInterceptor demoInterceptor;

        @Override   // 重写拦截器添加的方法
        public void addInterceptors(InterceptorRegistry registry) {
                                                     
            registry.addInterceptor(demoInterceptor)    // 注册拦截器 
                    .addPathPatterns("/**")             // 设置拦截路径， **任意级路径，*为一级路径
                    .excludePathPatterns("/login"       // 设置放行路径
                                        ,"/emp/**");    // 可填入复数个放行路径
        }
    }
```

---------------------------------------------------------------------------------------------------------------------------
#### 项目流程中的过滤器使用 - 虽然是过滤器，但是逻辑上和拦截器一样
<div align="center"> <img src=".\picture\过滤器流程图.png" alt="流程图" width="500"> </div>

---------------------------------------------------------------------------------------------------------------------------
#### 令牌校验模板代码 - Interceptor：

1. 定义拦截器
```java
    @Component
    public class TokenInterceptor implements HandlerInterceptor {

        @Autowired
        private JwtProperties jwtProperties;

        @Override
        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

            // 1. 获取请求路径
            // 2. 判断路径是否 包含 登录路径，如果有就直接放行
            //以上两个步骤在configuration包中的 WebConfig类中实现

            // 3. 获取请求头中的token
            String token = request.getHeader("token");
            // 4. 并判断token是否存在或是空字符串
            if (token == null || token.isEmpty()) {
                // 设置响应码为401，以返回给前端            401
                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                return false;
            }
            // 5. 校验token
            try{
                JwtUtil.parseJwt(token, jwtProperties.getSecretKey());
            }catch (Exception e){
                log.info("令牌非法，响应401");
                // 设置响应码为401，以返回给前端            401
                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                return false;
            }
            // 6. 校验通过则放行
            log.info("令牌合法，放行");
            return true;
        }
    }

```
2. 注册拦截器(configuration包中)
```java
    @Configuration
    public class WebConfig implements WebMvcConfigurer {

        @Autowired
        private TokenInterceptor tokenInterceptor;

        @Override
        public void addInterceptors(InterceptorRegistry registry) {

            registry.addInterceptor(demoInterceptor)    // 注册拦截器 
                    .addPathPatterns("/**")             // 设置拦截路径， **任意级路径，*为一级路径
                    .excludePathPatterns("/login"       // 设置放行路径
                                        ,"/emp/**");    // 可填入复数个放行路径
        }
    }
```